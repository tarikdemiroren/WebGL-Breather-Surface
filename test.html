<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breather Surface</title>
    <script type="text/javascript" src="Common/MV.js"></script>
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="webgl-canvas" width="600" height="600"></canvas>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            const canvas = document.getElementById("webgl-canvas");
            const gl = canvas.getContext("webgl");

            if (!gl) {
                console.error("Unable to initialize WebGL. Your browser may not support it.");
                return;
            }

            // Vertex and fragment shader source code
            const vertexShaderSource = `
                attribute vec4 a_position;
                uniform mat4 u_matrix;
                void main() {
                    gl_Position = u_matrix * a_position;
                }
            `;

            const fragmentShaderSource = `
                precision mediump float;
                void main() {
                    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Red color
                }
            `;

            // Compile shaders
            function compileShader(type, source) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error(`Shader compilation error: ${gl.getShaderInfoLog(shader)}`);
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

            // Link shaders into a program
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(`Program linking error: ${gl.getProgramInfoLog(program)}`);
                return;
            }

            gl.useProgram(program);

            // Create buffer and set vertices based on the parametrization
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

            // Define the parametrization function for the Breather surface
            function breatherSurface(u, v) {
                const aa = 0.8; // Replace with your desired values
                const wsqr = 1 - aa * aa;
                const w = Math.sqrt(wsqr);
                const denom = aa * (Math.pow(w * Math.cosh(aa * u), 2) + Math.pow(aa * Math.sin(w * v), 2));

                const x = -u + (2 * wsqr * Math.cosh(aa * u) * Math.sinh(aa * u) / denom);
                const y = 2 * w * Math.cosh(aa * u) * (-(w * Math.cos(v) * Math.cos(w * v)) - (Math.sin(v) * Math.sin(w * v))) / denom;
                const z = 2 * w * Math.cosh(aa * u) * (-(w * Math.sin(v) * Math.cos(w * v)) + (Math.cos(v) * Math.sin(w * v))) / denom;

                return vec4(x, y, z, 1.0);
            }

            const vertices = [];
            const numPointsU = 1000;
            const numPointsV = 1000;

            for (let i = 0; i < numPointsU; i++) {
                for (let j = 0; j < numPointsV; j++) {
                    const u = (i / (numPointsU - 1)) * 4 - 2; // Adjust the range as needed
                    const v = (j / (numPointsV - 1)) * Math.PI * 2;

                    const point = breatherSurface(u, v);
                    vertices.push(point);
                }
            }

            gl.bufferData(gl.ARRAY_BUFFER, flatten(vertices), gl.STATIC_DRAW);

            // Get attribute location and enable it
            const positionAttribLocation = gl.getAttribLocation(program, "a_position");
            gl.vertexAttribPointer(positionAttribLocation, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(positionAttribLocation);

            // Set the WebGL rendering context clear color
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            // Clear the color buffer with specified clear color
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.DEPTH_TEST);

            // Set up the perspective matrix
            var projectionMatrix = mat4();
            projectionMatrix = perspective(Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

            // Set up the model-view matrix
            var modelViewMatrix = mat4();
            modelViewMatrix = lookAt(vec3(0, 0, -100), vec3(0, 0, 0), vec3(0, 1, 0));

            var matrix = mat4();
            matrix = mult( projectionMatrix, modelViewMatrix);

            // Set up the perspective matrix
            const matrixLocation = gl.getUniformLocation(program, "u_matrix");

            gl.uniformMatrix4fv(matrixLocation, false, flatten(matrix));

            // Draw the vertices
            gl.drawArrays(gl.POINTS, 0, vertices.length / 4);
        });
    </script>
</body>

</html>